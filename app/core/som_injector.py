import undetected_chromedriver as uc
import logging

logger = logging.getLogger(__name__)

# The raw JavaScript payload that will be injected into the browser
SOM_JS_PAYLOAD = """
function injectSetOfMarks() {
    // Remove old marks if they exist
    const oldMarks = document.querySelectorAll('.applygenie-som-mark');
    oldMarks.forEach(el => el.remove());

    // Basic logic mapping for what is "interactive" visually, plus Z-Index occlusion depth
    const interactables = Array.from(document.querySelectorAll(
        "button, a, input, select, textarea, [role='button'], [role='link']"
    )).filter(el => {
        const style = window.getComputedStyle(el);
        const rect = el.getBoundingClientRect();
        
        // 1. Basic CSS Visibility check
        const isVisible = (
            style.display !== 'none' &&
            style.visibility !== 'hidden' &&
            style.opacity !== '0' &&
            rect.width > 5 &&
            rect.height > 5 &&
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth)
        );
        
        if (!isVisible) return false;
        
        // 2. Z-Index Occlusion Check
        // Calculate the physical center of the element
        const cX = rect.left + (rect.width / 2);
        const cY = rect.top + (rect.height / 2);
        
        // Ask the browser what element is physically on top at that exact center pixel
        const topEl = document.elementFromPoint(cX, cY);
        
        if (!topEl) return false;
        
        // If the topmost element is this element, or a child of this element (like an icon inside a button),
        // or if this element is a parent of the topmost (like a wrapper <a> around an <img>), it's truly visible.
        return el.contains(topEl) || topEl.contains(el);
    });

    // We store the mapping directly on the window object so Python can pull it back via execute_script
    window._applygenie_som_map = {};

    interactables.forEach((el, index) => {
        const id = index;
        const rect = el.getBoundingClientRect();

        // Save element reference and mapping coordinates
        window._applygenie_som_map[id] = {
            id: id,
            tagName: el.tagName,
            type: el.type || '',
            text: el.innerText ? el.innerText.trim() : '',
            ariaLabel: el.getAttribute('aria-label') || '',
            x: rect.x + (rect.width / 2),
            y: rect.y + (rect.height / 2),
            width: rect.width,
            height: rect.height,
            isInteractable: true // Mark as true since it passed visual filtering
        };

        // Draw the visual Bounding Box
        const box = document.createElement('div');
        box.className = 'applygenie-som-mark';
        box.style.position = 'absolute';
        box.style.left = (rect.left + window.scrollX) + 'px';
        box.style.top = (rect.top + window.scrollY) + 'px';
        box.style.width = rect.width + 'px';
        box.style.height = rect.height + 'px';
        box.style.border = '2px solid red';
        box.style.backgroundColor = 'rgba(255, 0, 0, 0.1)';
        box.style.pointerEvents = 'none'; // Don't block clicks!
        box.style.zIndex = '2147483647'; // Max integer to ensure it's on top
        
        // Draw the Label
        const label = document.createElement('div');
        label.innerText = id;
        label.style.position = 'absolute';
        label.style.top = '-15px'; // slightly above the box
        label.style.left = '0';
        label.style.backgroundColor = 'red';
        label.style.color = 'white';
        label.style.padding = '2px 4px';
        label.style.fontSize = '12px';
        label.style.fontWeight = 'bold';
        label.style.borderRadius = '2px';
        label.style.pointerEvents = 'none';

        box.appendChild(label);
        document.body.appendChild(box);
    });
    
    return window._applygenie_som_map;
}
return injectSetOfMarks();
"""

def inject_and_get_map(driver: uc.Chrome) -> dict:
    """
    Injects the Set-of-Mark Javascript into the current active Chrome tab.
    Draws the visual bounding boxes and returns a dictionary map of ID -> Element Metadata.
    """
    try:
        som_map = driver.execute_script(SOM_JS_PAYLOAD)
        logger.info(f"Set-Of-Mark successfully injected. Found {len(som_map)} interactables.")
        return som_map
    except Exception as e:
        logger.error(f"Failed to inject Set-of-Mark JS payload: {e}")
        return {}

def trigger_click_by_id(driver: uc.Chrome, som_map: dict, element_id: str) -> str:
    """
    Given the element ID generated by the SOM Map, this function leverages the 
    stored element reference inside the browser's javascript environment 
    to dispatch a perfect, physical-equivalent Javascript click on the specific node,
    regardless of hidden/obscured DOM rules.
    """
    try:
        eid = int(element_id)
        if str(eid) not in som_map and eid not in som_map:
            return f"Error: Element ID {eid} not found in the current mapping."
            
        script = f"""
            const interactables = Array.from(document.querySelectorAll(
                "button, a, input, select, textarea, [role='button'], [role='link']"
            )).filter(el => {{
                const style = window.getComputedStyle(el);
                const rect = el.getBoundingClientRect();
                
                const isVisible = (
                    style.display !== 'none' &&
                    style.visibility !== 'hidden' &&
                    style.opacity !== '0' &&
                    rect.width > 5 &&
                    rect.height > 5 &&
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                );
                
                if (!isVisible) return false;
                
                const cX = rect.left + (rect.width / 2);
                const cY = rect.top + (rect.height / 2);
                const topEl = document.elementFromPoint(cX, cY);
                if (!topEl) return false;
                
                return el.contains(topEl) || topEl.contains(el);
            }});
            
            // Re-find the exact element node in the live DOM
            const targetEl = interactables[{eid}];
            if (!targetEl) return false;
            
            targetEl.scrollIntoView({{block: 'center'}});
            targetEl.click();
            return true;
        """
        
        success = driver.execute_script(script)
        if success:
            return f"Successfully executed native click on Element ID: {eid}."
        else:
            return f"Error: Failed to execute click. Element {eid} may have disappeared from the DOM."
            
    except Exception as e:
        return f"CRITICAL Navigation Error clicking {element_id}: {str(e)}"
        
def trigger_type_by_id(driver: uc.Chrome, som_map: dict, element_id: str, text: str) -> str:
    """
    Given an element ID, injects Javascript to securely focus and input the targeted string.
    """
    try:
        eid = int(element_id)
        if str(eid) not in som_map and eid not in som_map:
            return f"Error: Element ID {eid} not found in the current mapping."
            
        # We must use JS to properly trigger the React/Angular event listeners so the typing actually registers
        # Simply changing `.value` often fails on complex SPAs.
        script = f"""
            const interactables = Array.from(document.querySelectorAll(
                "button, a, input, select, textarea, [role='button'], [role='link']"
            )).filter(el => {{
                const style = window.getComputedStyle(el);
                const rect = el.getBoundingClientRect();
                
                const isVisible = (
                    style.display !== 'none' &&
                    style.visibility !== 'hidden' &&
                    style.opacity !== '0' &&
                    rect.width > 5 &&
                    rect.height > 5 &&
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                );
                
                if (!isVisible) return false;
                
                const cX = rect.left + (rect.width / 2);
                const cY = rect.top + (rect.height / 2);
                const topEl = document.elementFromPoint(cX, cY);
                if (!topEl) return false;
                
                return el.contains(topEl) || topEl.contains(el);
            }});
            
            const targetEl = interactables[{eid}];
            if (!targetEl) return false;
            
            targetEl.scrollIntoView({{block: 'center'}});
            targetEl.focus();
            
            // Simulate full typing event chain for React/Vue
            targetEl.value = '{text}';
            targetEl.dispatchEvent(new Event('input', {{ bubbles: true }}));
            targetEl.dispatchEvent(new Event('change', {{ bubbles: true }}));
            return true;
        """
        
        success = driver.execute_script(script)
        if success:
            return f"Successfully typed '{text}' into Element ID: {eid}."
        else:
            return f"Error: Failed to type. Element {eid} may have disappeared."
            
    except Exception as e:
        return f"CRITICAL Navigation Error typing into {element_id}: {str(e)}"
